
# Multithread assessment - Problem description

## The objective: 
Create an application that simulates sensors logging info to a persistent datasource.
With the following restraints:
- Simulate the interaction between sensors and network, the network should have a limit of 5 messages maximum at once.
- Use multithreading, create 5 sensors that should be registering to the log service. All five sensors should work 
simultaneously without blocking each other and use same network restrains.
- Sensors should log every 5 seconds, and a timestamp should persist onto datasource.
- Sensors most generate the following info, timestamp, sensor name, value (integer between -100 and 100).
- Model, most define all properties needed to persist data into datasource.
- Model most have a timestamp type, id, sensor name, value.
- Repository class should contain all logic needed to use a file/memory database, and convert logic for model to allow 
insertion into database.
- Use PEP8 conventions for coding.

### EXTRA
- Sensors: create multiple sensors using the default sensor of 5 seconds delay as base, 
and use factory pattern to create multiple types sensors with varying delay time.
- Repository: create an implementation that allows to change datasource options before running.
- Use type hinting.

![Diagram solution](multithread_assesment.png)

Modify classes or create new ones as you find needed, also you are free to use whatever library you want.
Don't forget to include the requirements file.

# Solution
## Design principles
The most important principle in software design is to make the code easy to understand, extend and  maintain. 
### Encapsulate what varies
The parts of the code that we expect to be subject to change in the future should be isolated from the parts that can be assumed to be stable.
### Strive for deep classes and functions
According to [John Ousterhout](https://youtu.be/bmSAYlu0NcY): Classes and functions should provide substantial functionality, but have a simple interface. The purpose is to make classes and functions easy to use. 
### Classes should be closed for modification - open for extension
Classes should be possible to extend with new functionality without modifying existing code.

## Design requirements
### Candidates for variation/modification
- The logger used. Logging could go to file (csv, sqlite3), to network-connected SQL-database, or simply printed to screen. 
- The part of the sensor that actually acquires data. This is referred to as the probe. In the simulation this is just a function that generates a random number. In practice it would be something else.
- The data model. This is related to the previous item. Some sensors will generate data of different kind, including array-like data.
- The number of sensors.
### Constraints
- Access to shared resources by different threads must be synchronized using locks.
- The system should close down gracefully, releasing any resources.
## Design
### Data model
The `service.model.Message` class represents the data generated by the sensors which are to be logged. According to the specifications, the attributes include time stamp, unique ID, name, and data value. Transmitting the data requires that the model state is represented as a string, and for this json is used. It must also be possible to instantiate a new data object from a json-string.  
### Sensors - clients
The sensors run in separate processes, and are considered to be the clients in the solution. This makes sense from the objective of the system, which is to provide logging functionality for sensors generating data. The communication is over TCP sockets, since this provides loose coupling and facilitates a distributed sensor system with sensor code running on embedded computers. Each sensor object has two important attributes: The message object (`service.model.Message`) and the connection object (`utils.network.ClientConnection`).
### Network connection - client side
The connection object on the client side maintain information (address, port) and state about the connection (open, closed). It provides a simple interface to send a data object.
### Network connection - server side
A webserver (`utils.network.Server`) is running on the server side, listening for connections, and spawning threads to handle socket connections to sensor objects. The threads run callable objects (`utils.network.ServerConnection`). Each object (each in a separate thread)  will read and parse the incoming json-string, (re)create the message object on the server side and call the logger object.  
### Logging
The `repository.logging.Logger` class provides a simple interface for logging `Message` objects, with calls to the `append(m : Message)` method. It provides thread-safe behavior, due to the use of a lock to ensure that calls to `append` are atomic.   The [Singleton pattern](https://refactoring.guru/design-patterns/singleton/python/example) is used to ensure only one logger is in use. The logger object maintains a list of `service.repository.Repository` objects. The logger forwards the call to `append` to each of the `Repository` objects. Different types of repository objects can be instantiated and added to the list using static methods of the `Logger`class.
### Repositories
There are three classes defined that implements the `append(m : Message)` function. Objects of class `ScreenRepository` will simply print the data to the screen, `SQLiteRepository` will update a local SQLite database file, and `CSVRepository` will append the data as a row to a csv file. Since the `Logger` class makes use of a lock to make calls to `append` atomic, there is no need for the repository objects to do so.
## Implementation
## Getting started
### Installation
### Running the simulation
- Locally
- Notebook on Google colab
